current_DEATH_prob  <- annual_p_logistic(mortality_risk_equations$DEATHYSEVENT, current_patient %>% select(risk_factors_mortality))$p
}
# Sampling "dead" status
current_DEATH_event <- rbinom(1,1,current_DEATH_prob)
#print(current_DEATH_prob)
current_patient$dead <- current_DEATH_event
### INFORMAL CARE AND PRODUCTIVITY COSTS: Added 29/08/2020
# INFORMAL CARE
# Probability of receiving at least weekly informal care for a whole year is calculated using a Bernoulli distribution.
current_inf_care_prob <- annual_p_bernoulli(informal_care_equations$informal_care_coef, current_patient %>% select(risk_factors_informal))$p
current_patient$INF.CARE <- rbinom(1,1,current_inf_care_prob) #INF.CARE = yes/no
# If INF.CARE = yes, then calculate hours per day, and then total per year: Gamma distribution for now but other options are possible.
# Make parameters of the gamma distribution input parameters of the function
# Gamma distribution updated 10/12/2020: primary analysis central countries
if(current_patient$INF.CARE == 1){current_patient$INF.CARE <- rgamma(1, 1.753152, 1/1.022368)*365.25}
# Note here: Irene suggested we might better use the mean/median
# PRODUCTIVITY LOSS -- main assumptions:
# 1. Short-term productivity loss costs: only for EMPLOYED patients based on sick days --> Assume fix 14 working days based on data. This could be changed.
# 2. Permanent (one-off) productivity loss costs: only employed patients can get unemployed and incur productivity costs the year after they get unemployed. Friction method.
# 3. After patients become unemployed, they are assumed to continue like that in the simulation --> No more productivity loss costs
# If currently employed, then apply first short-term productivity costs
if(current_patient$EMPLOYED == 1){
# Short-term productivity costs (sick days)
# Calculate number of worked hours per week: assume mean value, different for male and females. See e-mail 10/12/2020.
# This could be updated if we are able to fit a distribution.
current_worked_hours_week <- if_else(current_patient$FEMALE == 1, 26.5096273, 33.8016304)
current_worked_hours_day <- current_worked_hours_week/5
# Assumption 11/12/2020: working days per year lost due to sickness --> Apply median value for central European countries.
# The median was chosen as opposed to the mean due to the skewness of the distribution (mean seems to be very large).
# There is no probability distribution fit to the data. Therefore, values are fixed. This could be updated if we manage to fit.
# The model distinguishes between days lost due to 1) diabetes and 2) diabetes with heart attack/stroke. The latter is
# applied at the year of the event only.
# Values are 14 days for diabetes and 27.5 for diabetes + CHF/stroke
# The definition of this variable in SHARE is: 'a heart attack including myocardial infarction or coronary thrombosis or
# any other heart problem including congestive heart failure'.
# So it could either be an MI event, or onset of heart failure. I therefore think these sick days should apply to both patients
# with congestive heart failure and patients with a myocardial infarction, but I think also to patients with ischemic heart disease.
sick_hours_year <- if_else(current_patient$STROKE.EVENT+current_patient$MI.EVENT+current_patient$CHF.EVENT+current_patient$IHD.EVENT>0,
current_worked_hours_day*27.5,
current_worked_hours_day*14)
# Cost of an hour sick: based the productivity costs per hour on Eurostat: for the UK it is 28.50 Euros per hour (not specified by gender) in 2019.
# https://ec.europa.eu/eurostat/databrowser/view/tps00173/default/table?lang=en.
# Inflated to 2020 is 28.93 -->> https://www.officialdata.org/europe/inflation/2019?amount=28.50
# And converted into GBP is 26.6369 -->> https://www.xe.com/currencyconverter/convert/?Amount=28.93&From=EUR&To=GBP
cost_hour_sick <- 26.6369
# Multiply number of sick hours by the costs of an hour
current_patient$PROD.LOSS <- sick_hours_year*cost_hour_sick
# Permanent (one-off) prod. loss costs
# Calculate first the probability of losing job (Bernoulli distribution).
current_jobless_prob <- annual_p_bernoulli(informal_care_equations$prod_costs_coef, current_patient %>% select(risk_factors_prod))$p
current_jobless <- rbinom(1,1,current_jobless_prob)
# If jobless, then apply permanent cost (one-off) cost: friction method as proportion of a maximum of 2.7 months (re-calculated as days).
# To do: make 2.7 months an input parameter of the model. We can assume a friction period in the UK of 2.7 months based on this publication:
#http://pure-oai.bham.ac.uk/ws/files/40800976/Kigozi_et_al_2017_Health_Economics.pdf
if(current_jobless == 1){
# Add permanent cost (one-off) cost to cost of sick days
current_patient$PROD.LOSS <- current_patient$PROD.LOSS + cost_hour_sick*(2.7*365.25/12)*current_worked_hours_day/8
# Update employed status
current_patient$EMPLOYED <- 0
}
}
# Update patient characteristics   #
# We first copy all the previous characteristics
current_patient_update <- current_patient # Check: Do we need this? Or can we update directly current_patient?
# Update the history characteristics
current_patient_update$CHF.HIST    <- if_else(current_patient$CHF.EVENT + current_patient$CHF.HIST == 0, 0, 1)
current_patient_update$IHD.HIST    <- if_else(current_patient$IHD.EVENT + current_patient$IHD.HIST == 0, 0, 1)
current_patient_update$MI.HIST     <- if_else(current_patient$MI.EVENT + current_patient$MI.HIST == 0,0,1)
current_patient_update$STROKE.HIST <- if_else(current_patient$STROKE.EVENT + current_patient$STROKE.HIST == 0, 0, 1)
current_patient_update$BLIND.HIST  <- if_else(current_patient$BLIND.EVENT + current_patient$BLIND.HIST == 0, 0, 1)
current_patient_update$ULCER.HIST  <- if_else(current_patient$ULCER.EVENT + current_patient$ULCER.HIST == 0, 0, 1)
current_patient_update$AMP.HIST    <- if_else(current_patient$AMP1.EVENT + current_patient$AMP2.EVENT + current_patient$AMP.HIST == 0, 0, 1)
current_patient_update$RENAL.HIST  <- if_else(current_patient$RENAL.EVENT + current_patient$RENAL.HIST == 0, 0, 1)
# Update risk factors
### 23/11/2020: we are distinguishing between risk factors that will be updated in every loop iteration (1 year)
### and those depending on treatment effect.
### For treatment effect parameters we are going to use two additional parameters: one to indicate the total duration
### of the treatment effect and another one to indicate when a decline on the effect will start.
### For example, if the total duration is 10 years, we will assume that after 10 years there is no more tx effect.
### If the decline starts at year 5, then we will assume full effect for years 1 to 5, and decline from 6 to 10.
### We need to decide how the decline will be modeled. We may consider several options.
### Parameters that remain at their baseline value through the simulation will not be shown here.
### No Tx effect parameters
current_patient_update$SDURATION <- current_patient$SDURATION + 1
current_patient_update$CURR.AGE <- current_patient$CURR.AGE + 1
current_patient_update$YEAR <- current_patient$YEAR + 1 # Note YEAR is duration of diabetes
# Added 29/08/2020: age scaled parameters
current_patient_update$CURR.AGE.SCALE.INF  <- (current_patient$CURR.AGE - 73.75225)/9.938705 #hardcoded values from data
current_patient_update$CURR.AGE.SCALE.PROD <- (current_patient$CURR.AGE - 70.34077)/9.578899 #hardcoded values from data
if(current_patient_update$CURR.AGE >= retirement_age_input){
current_patient_update$EMPLOYED <- 0
current_patient_update$PROD.LOSS <- 0
}
# Force death at 99 years: DECIDE THIS TOO
if(current_patient_update$CURR.AGE >= 99){current_patient_update$dead <- 1}
### Tx effect parameters
# HbA1c
# Note: unique(simulation_baseline_patients$HbA1c) has the HbA1c baseline value. Note we have at baseline only 2 patients
# with the same characteristics except one is male and the other female.
# We need "unique" because simulation_baseline_patients is already a matrix with the size of the simulation
if(current_patient_update$SDURATION == treatment_effect_HbA1c_input[2]){
current_patient_update$HbA1c <- min(max(5, current_patient$HbA1c + treatment_effect_HbA1c_input[1]),18) #23/11/2020
}
if(current_patient_update$SDURATION %in% treatment_effect_HbA1c_input[4]:treatment_effect_HbA1c_input[3]){
current_patient_update$HbA1c <- min(current_patient$HbA1c - (treatment_effect_HbA1c_input[1])/(treatment_effect_HbA1c_input[3]-treatment_effect_HbA1c_input[4]),unique(simulation_baseline_patients$HbA1c)) #23/11/2020
}
# BMI
current_patient_update$BMI <- current_patient$BMI #- treatment_effect_BMI_input # treatment effect currently removed
# Based on the above BMI, we should update BMI1 and BMI3
current_patient_update$BMI1 <- if_else(current_patient_update$BMI < 18.5, 1, 0)
current_patient_update$BMI3 <- if_else(current_patient_update$BMI >= 25, 1, 0)
# LDL: same approach as for HbA1c14/12/2020
# QUESTION: natural bounds for LDL???
if(current_patient_update$SDURATION == treatment_effect_LDL_input[2]){
current_patient_update$LDL <- min(max(0, current_patient$LDL + treatment_effect_LDL_input[1]),50)
}
if(current_patient_update$SDURATION %in% treatment_effect_LDL_input[4]:treatment_effect_LDL_input[3]){
current_patient_update$LDL <- min(current_patient$LDL - (treatment_effect_LDL_input[1])/(treatment_effect_LDL_input[3]-treatment_effect_LDL_input[4]),unique(simulation_baseline_patients$LDL))
}
# HDL: same approach as for HbA1c14/12/2020
# QUESTION: natural bounds for HDL???
if(current_patient_update$SDURATION == treatment_effect_HDL_input[2]){
current_patient_update$HDL <- min(max(0, current_patient$HDL + treatment_effect_HDL_input[1]),50)
}
if(current_patient_update$SDURATION %in% treatment_effect_HDL_input[4]:treatment_effect_HDL_input[3]){
current_patient_update$HDL <- max(current_patient$HDL-(treatment_effect_HDL_input[1])/(treatment_effect_HDL_input[3]-treatment_effect_HDL_input[4]),unique(simulation_baseline_patients$HDL))
# CAREFUL HERE: I put max instead of min above because the treatment effect is positive and not negative.
# try to find a general solution, maybe using absolute value
}
# When all characteristics are updated, we add these to the patient history
simulation_patients_history <- bind_rows(simulation_patients_history,current_patient_update[history_characteristics])
# And update current patient and go up to while loop
current_patient <- current_patient_update
# All the _event and .EVENT variables have to be reset to 0 because for the next year it only counts .HIST
# Note "event_vars" defined in aux_functions.R
current_patient[event_vars] <- 0
if(current_patient$EMPLOYED == 0){current_patient$PROD.LOSS <- 0} # needed here or somewhere else? It seems to work though
} #end while loop and move to another patient
# Update patient index
patient_index <- patient_index + 1
} #end for loop in number of patients
########## MAIN PART II: Calculate Costs ##########
# All cost inputs were sourced from the MH2020 diabetes challenge. We need NL costs.
cost_discount_factor <- (1+cost_disc_rate_input)^(simulation_patients_history$SDURATION)
# Complication costs are dependent on age, gender and alive status
complication_cost_inputs <- data.frame(ifelse(unique(simulation_patients_history$FEMALE) == 0, male_cost_inputs,female_cost_inputs) )
if(unique(simulation_patients_history$FEMALE) == 0){complication_cost_inputs <- male_cost_inputs}else{complication_cost_inputs <- female_cost_inputs}
complication_cost_matrix <- inner_join(simulation_patients_history[c("CURR.AGE","FEMALE","dead",
"IHD.EVENT", "IHD.HIST", "MI.EVENT", "MI.HIST", "CHF.EVENT", "CHF.HIST",
"STROKE.EVENT", "STROKE.HIST", "AMP1.EVENT", "AMP2.EVENT", "AMP.HIST",
"BLIND.EVENT","BLIND.HIST", "ULCER.EVENT", "ULCER.HIST")],
complication_cost_inputs, by = 'CURR.AGE')
#Ischemic heart disease/Angina
fatal_IHD_cost      <- (complication_cost_matrix$IHD.FATAL*complication_cost_matrix$IHD.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_IHD_cost   <- (complication_cost_matrix$IHD.NONFATAL*complication_cost_matrix$IHD.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_IHD_cost <- (complication_cost_matrix$IHD.SUB*complication_cost_matrix$IHD.HIST*(1-complication_cost_matrix$IHD.EVENT))/cost_discount_factor
simulation_patients_history$IHD.COST <- (fatal_IHD_cost + nonfatal_IHD_cost + subsequent_IHD_cost)
# Myocardial infarction
fatal_MI_cost      <- (complication_cost_matrix$MI.FATAL*complication_cost_matrix$MI.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_MI_cost   <- (complication_cost_matrix$MI.NONFATAL*complication_cost_matrix$MI.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_MI_cost <- (complication_cost_matrix$MI.SUB*complication_cost_matrix$MI.HIST*(1-complication_cost_matrix$MI.EVENT))/cost_discount_factor
simulation_patients_history$MI.COST <- (fatal_MI_cost + nonfatal_MI_cost + subsequent_MI_cost)
# Heart failure
fatal_CHF_cost      <- (complication_cost_matrix$CHF.FATAL*complication_cost_matrix$CHF.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_CHF_cost   <- (complication_cost_matrix$CHF.NONFATAL*complication_cost_matrix$CHF.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_CHF_cost <- (complication_cost_matrix$CHF.SUB*complication_cost_matrix$CHF.HIST*(1-complication_cost_matrix$CHF.EVENT))/cost_discount_factor
simulation_patients_history$CHF.COST <- (fatal_CHF_cost + nonfatal_CHF_cost + subsequent_CHF_cost)
#Stroke
fatal_STROKE_cost      <- (complication_cost_matrix$STROKE.FATAL*complication_cost_matrix$STROKE.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_STROKE_cost   <- (complication_cost_matrix$STROKE.NONFATAL*complication_cost_matrix$STROKE.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_STROKE_cost <- (complication_cost_matrix$STROKE.SUB*complication_cost_matrix$STROKE.HIST*(1-complication_cost_matrix$STROKE.EVENT))/cost_discount_factor
simulation_patients_history$STROKE.COST <- (fatal_STROKE_cost + nonfatal_STROKE_cost + subsequent_STROKE_cost)
# Amputation 	0	15,153	5,328	Alva et al. 2015 [1]
# Note here we have in the model AMP1.EVENT and AMP2.EVENT but in terms of costs, there is no distinction
# Question: in case of 2nd amp, should we consider the sum of the event + history of first?
# Not sure whether costs for amputation are calculated ok. It should be consistent with other events when a 2nd event can occur.
fatal_AMP_cost      <- (complication_cost_matrix$AMP.FATAL*complication_cost_matrix$AMP1.EVENT*complication_cost_matrix$dead + complication_cost_matrix$AMP.FATAL*complication_cost_matrix$AMP2.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_AMP_cost   <- (complication_cost_matrix$AMP.NONFATAL*complication_cost_matrix$AMP1.EVENT*(1-complication_cost_matrix$dead) + complication_cost_matrix$AMP.NONFATAL*complication_cost_matrix$AMP2.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_AMP_cost <- (complication_cost_matrix$AMP.SUB*complication_cost_matrix$AMP.HIST*(1-complication_cost_matrix$AMP1.EVENT)*(1-complication_cost_matrix$AMP2.EVENT))/cost_discount_factor
simulation_patients_history$AMP.COST <- (fatal_AMP_cost + nonfatal_AMP_cost + subsequent_AMP_cost)
#Blindness
fatal_BLIND_cost      <- (complication_cost_matrix$BLIND.FATAL*complication_cost_matrix$BLIND.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_BLIND_cost   <- (complication_cost_matrix$BLIND.NONFATAL*complication_cost_matrix$BLIND.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_BLIND_cost <- (complication_cost_matrix$BLIND.SUB*complication_cost_matrix$BLIND.HIST*(1-complication_cost_matrix$BLIND.EVENT))/cost_discount_factor
simulation_patients_history$BLIND.COST <- (fatal_BLIND_cost + nonfatal_BLIND_cost + subsequent_BLIND_cost)
# Ulcer
fatal_ULCER_cost      <- (complication_cost_matrix$ULCER.FATAL*complication_cost_matrix$ULCER.EVENT*complication_cost_matrix$dead)/cost_discount_factor
nonfatal_ULCER_cost   <- (complication_cost_matrix$ULCER.NONFATAL*complication_cost_matrix$ULCER.EVENT*(1-complication_cost_matrix$dead))/cost_discount_factor
subsequent_ULCER_cost <- (complication_cost_matrix$ULCER.SUB*complication_cost_matrix$ULCER.HIST*(1-complication_cost_matrix$ULCER.EVENT))/cost_discount_factor
simulation_patients_history$ULCER.COST <- (fatal_ULCER_cost + nonfatal_ULCER_cost + subsequent_ULCER_cost)
# Cost in the absence of complications 	1,990	Alva et al. 2015 [1]
simulation_patients_history$NOCOMP.COST <- (complication_cost_matrix$NOCOMP*(1-complication_cost_matrix$IHD.EVENT)*(1-complication_cost_matrix$MI.EVENT)*
(1-complication_cost_matrix$CHF.EVENT)*(1-complication_cost_matrix$STROKE.EVENT)*(1-complication_cost_matrix$AMP1.EVENT)*
(1-complication_cost_matrix$AMP2.EVENT)*(1-complication_cost_matrix$BLIND.EVENT)*(1-complication_cost_matrix$ULCER.EVENT))/cost_discount_factor
# Intervention costs: only applied the first year of simulation. Then equal to 0.
simulation_patients_history$TX.COST <- if_else(simulation_patients_history$SDURATION == 0, (tx_cost_input)/cost_discount_factor,0)
### Societal costs: Added 29/08/2020
# Informal care and productivity loss: We calculated above INF.CARE & PROD.LOSS = 0/1 but costs have to be calculated here:
# Informal care cost per hour assumed = ?20.26. Make this an input parameter in the model.
# Calculation: From Weatherly et al. 2014 "Valuing Informal Care for Economic Evaluation". Table 1 estimate from Wilson et al. 2009 = ?13.11 (2004/UK)
# Inflated to 2020 costs using https://www.officialdata.org/uk/inflation/2004?amount=13.11
simulation_patients_history$INF.CARE.COST <- (20.26*simulation_patients_history$INF.CARE*(1-simulation_patients_history$dead) + 20.26/2*simulation_patients_history$INF.CARE*simulation_patients_history$dead)/cost_discount_factor
simulation_patients_history$PROD.LOSS.COST <- (simulation_patients_history$PROD.LOSS*(1-simulation_patients_history$dead) + 1/2*simulation_patients_history$PROD.LOSS*simulation_patients_history$dead)/cost_discount_factor
# Future costs are dependent on age, gender and alive status: add explanation later
future_cost_matrix <- inner_join(simulation_patients_history[c("CURR.AGE","FEMALE","dead")],
future_medical_cost_inputs, by = 'CURR.AGE')
future_cost_matrix <- inner_join(future_cost_matrix,future_nonmedical_cost_inputs, by = 'CURR.AGE')
simulation_patients_history$FUTURE.COST.MEDICAL <- ((1-future_cost_matrix$FEMALE)*(1-future_cost_matrix$dead)*future_cost_matrix[,6] +
(1-future_cost_matrix$FEMALE)*future_cost_matrix$dead*future_cost_matrix[,4] +
future_cost_matrix$FEMALE*(1-future_cost_matrix$dead)*future_cost_matrix[,7] +
future_cost_matrix$FEMALE*future_cost_matrix$dead*future_cost_matrix[,5])/cost_discount_factor
simulation_patients_history$FUTURE.COST.NONMEDICAL <- future_cost_matrix[,8]/cost_discount_factor
# Total annual costs discounted
simulation_patients_history$TOTAL.COST <- (simulation_patients_history$IHD.COST +
simulation_patients_history$MI.COST +
simulation_patients_history$CHF.COST +
simulation_patients_history$STROKE.COST +
simulation_patients_history$AMP.COST +
simulation_patients_history$BLIND.COST +
simulation_patients_history$ULCER.COST +
simulation_patients_history$NOCOMP.COST +
simulation_patients_history$TX.COST +
simulation_patients_history$INF.CARE.COST +
simulation_patients_history$PROD.LOSS.COST +
simulation_patients_history$FUTURE.COST.MEDICAL +
simulation_patients_history$FUTURE.COST.NONMEDICAL)
########## MAIN PART III: Calculate QALYs ##########
# Discounting is applied to total QALYs only at this moment.
qaly_discount_factor <- ((1+qol_disc_rate_input)^(simulation_patients_history$SDURATION)) # Note if SDURATION starts at 0 then we don't need to add -1
# Age and gender dependent
qol_matrix <- inner_join(simulation_patients_history[c("CURR.AGE","FEMALE","CHF.EVENT","IHD.EVENT","MI.EVENT", "STROKE.EVENT",
"ULCER.EVENT", "AMP1.EVENT","AMP2.EVENT", "BLIND.EVENT", "RENAL.EVENT","BMI")],qol_inputs, by = 'CURR.AGE')
# The following event variables are at this moment included in the model
# CHF.EVENT	IHD.EVENT	MI.EVENT	STROKE.EVENT	ULCER.EVENT	AMP.EVENT	BLIND.EVENT	RENAL.EVENT	BMI.HIGH
# -0.089	   -0.074	    -0.045	  -0.135	     -0.14	      -0.231	   -0.061	     -0.135	   -0.005
# Coronary heart disease group:
qol_matrix$CHF.EVENT <- qol_matrix$CHF.EVENT*(-0.089)
qol_matrix$IHD.EVENT <- qol_matrix$IHD.EVENT*(-0.074)
qol_matrix$MI.EVENT <- qol_matrix$MI.EVENT*(-0.045)
chd_qaly_male   <- (1-qol_matrix$FEMALE)*pmin(qol_matrix$CHF.EVENT,qol_matrix$IHD.EVENT,qol_matrix$MI.EVENT)
chd_qaly_female <- qol_matrix$FEMALE*pmin(qol_matrix$CHF.EVENT,qol_matrix$IHD.EVENT,qol_matrix$MI.EVENT)
simulation_patients_history$CHD.QALY <- (chd_qaly_male + chd_qaly_female)/qaly_discount_factor
# Cerebrovascular disease: only stroke
qol_matrix$STROKE.EVENT <- qol_matrix$STROKE.EVENT*(-0.135)
stroke_qaly_male   <- (1-qol_matrix$FEMALE)*qol_matrix$STROKE.EVENT
stroke_qaly_female <- qol_matrix$FEMALE*qol_matrix$STROKE.EVENT
simulation_patients_history$STROKE.QALY <- (stroke_qaly_male + stroke_qaly_female)/qaly_discount_factor
# Neuropathy group: so far we have ULCER.EVENT, AMP1.EVENT and AMP2.EVENT
qol_matrix$ULCER.EVENT <- qol_matrix$ULCER.EVENT*(-0.14)
qol_matrix$AMP1.EVENT  <- qol_matrix$AMP1.EVENT*(-0.231)
qol_matrix$AMP2.EVENT  <- qol_matrix$AMP2.EVENT*(-0.231)
neuro_qaly_male   <- (1-qol_matrix$FEMALE)*pmin(qol_matrix$ULCER.EVENT,qol_matrix$AMP1.EVENT,qol_matrix$AMP2.EVENT)
neuro_qaly_female <- qol_matrix$FEMALE*pmin(qol_matrix$ULCER.EVENT,qol_matrix$AMP1.EVENT,qol_matrix$AMP2.EVENT)
simulation_patients_history$NEUROPATHY.QALY <- (neuro_qaly_male + neuro_qaly_female)/qaly_discount_factor
# Retinopathy: so far we only have BLIND.EVENT
qol_matrix$BLIND.EVENT <- qol_matrix$BLIND.EVENT*(-0.061)
blind_qaly_male   <- (1-qol_matrix$FEMALE)*qol_matrix$BLIND.EVENT
blind_qaly_female <- qol_matrix$FEMALE*qol_matrix$BLIND.EVENT
simulation_patients_history$BLIND.QALY <- (blind_qaly_male + blind_qaly_female)/qaly_discount_factor
# Nephropathy: so far we only have RENAL.EVENT: assumed disutility from haemodialysis but not sure
qol_matrix$RENAL.EVENT <- qol_matrix$RENAL.EVENT*(-0.135)
renal_qaly_male   <- (1-qol_matrix$FEMALE)*qol_matrix$RENAL.EVENT
renal_qaly_female <- qol_matrix$FEMALE*qol_matrix$RENAL.EVENT
simulation_patients_history$RENAL.QALY <- (renal_qaly_male + renal_qaly_female)/qaly_discount_factor
# Comorbidity: Excess BMI (each unit above 25 kg/m2)	-0.006	-0.008	-0.004
qol_matrix$BMI <- max(qol_matrix$BMI-25,0)*(-0.005)
bmi_qaly_male   <- (1-qol_matrix$FEMALE)*qol_matrix$BMI
bmi_qaly_female <- qol_matrix$FEMALE*qol_matrix$BMI
simulation_patients_history$BMI.QALY <- (bmi_qaly_male + bmi_qaly_female)/qaly_discount_factor
# Note: 25 in formula above is HARDCODED!
# Total annual utilities
total_utils <- ((1-qol_matrix$FEMALE)*(qol_matrix$BASELINE.MALE) + qol_matrix$FEMALE*qol_matrix$BASELINE.FEMALE +
simulation_patients_history$CHD.QALY + simulation_patients_history$STROKE.QALY +
simulation_patients_history$NEUROPATHY.QALY + simulation_patients_history$BLIND.QALY +
simulation_patients_history$RENAL.QALY + simulation_patients_history$BMI.QALY)
# Annual discounted QALYs
simulation_patients_history$QALY <- (total_utils*(1-simulation_patients_history$dead) + (total_utils/2)*simulation_patients_history$dead)
#View(simulation_patients_history)
########## MAIN PART IV: Calculate aggregated results ##########
# To be completed: add clinical outcomes - life expectancy and events
# Life expectancy
mean_life_expectancy <- mean(simulation_patients_history[which(simulation_patients_history$dead==1),"SDURATION"])
# Event rates: note events calculated differently depending on how were defined: .EVENT or .HIST
# Total number of events per patient during lifetime and rate per year
cum_CHF <- aggregate(simulation_patients_history$CHF.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_CHF_rate <- sum(cum_CHF$x)/patient_size_input
cum_BLIND <- aggregate(simulation_patients_history$BLIND.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_BLIND_rate <- sum(cum_BLIND$x)/patient_size_input
cum_ULCER <- aggregate(simulation_patients_history$ULCER.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_ULCER_rate <- sum(cum_ULCER$x)/patient_size_input
cum_AMP1 <- aggregate(simulation_patients_history$AMP1.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_AMP1_rate <- sum(cum_AMP1$x)/patient_size_input
cum_AMP2 <- aggregate(simulation_patients_history$AMP2.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_AMP2_rate <- sum(cum_AMP2$x)/patient_size_input
cum_MI <- aggregate(simulation_patients_history$MI.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_MI_rate <- sum(cum_MI$x)/patient_size_input
cum_STROKE <- aggregate(simulation_patients_history$STROKE.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_STROKE_rate <- sum(cum_STROKE$x)/patient_size_input
cum_RENAL <- aggregate(simulation_patients_history$RENAL.EVENT, list(Patient = simulation_patients_history$SIMID), sum)
mean_RENAL_rate <- sum(cum_RENAL$x)/patient_size_input #mean(cum_RENAL$x)/mean_life_expectancy # note this could be per patient or per time
# Total costs per patient during lifetime and average per patient
total_costs_patient <- aggregate(simulation_patients_history$TOTAL.COST, list(Patient = simulation_patients_history$SIMID), sum)
mean_total_costs <- sum(total_costs_patient$x)/patient_size_input
# Breakdown costs:
tx_costs_patient <- aggregate(simulation_patients_history$TX.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_tx_costs <- sum(tx_costs_patient$x)/patient_size_input
ihd_costs_patient <- aggregate(simulation_patients_history$IHD.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_ihd_costs <- sum(ihd_costs_patient$x)/patient_size_input
mi_costs_patient <- aggregate(simulation_patients_history$MI.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_mi_costs <- sum(mi_costs_patient$x)/patient_size_input
chf_costs_patient <- aggregate(simulation_patients_history$CHF.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_chf_costs <- sum(chf_costs_patient$x)/patient_size_input
stroke_costs_patient <- aggregate(simulation_patients_history$STROKE.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_stroke_costs <- sum(stroke_costs_patient$x)/patient_size_input
amp_costs_patient <- aggregate(simulation_patients_history$AMP.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_amp_costs <- sum(amp_costs_patient$x)/patient_size_input
blind_costs_patient <- aggregate(simulation_patients_history$BLIND.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_blind_costs <- sum(blind_costs_patient$x)/patient_size_input
ulcer_costs_patient <- aggregate(simulation_patients_history$ULCER.COST , list(Patient = simulation_patients_history$SIMID), sum)
mean_ulcer_costs <- sum(ulcer_costs_patient$x)/patient_size_input
mean_complication_costs <- mean_ihd_costs + mean_mi_costs + mean_chf_costs + mean_stroke_costs + mean_amp_costs + mean_blind_costs + mean_ulcer_costs
# No complication costs
nocomp_costs_patient <- aggregate(simulation_patients_history$NOCOMP.COST  , list(Patient = simulation_patients_history$SIMID), sum)
mean_nocomp_costs <- sum(nocomp_costs_patient$x)/patient_size_input
# Informal care and productivity
inf_care_costs_patient <- aggregate(simulation_patients_history$INF.CARE.COST, list(Patient = simulation_patients_history$SIMID), sum)
mean_inf_care_costs <- sum(inf_care_costs_patient$x)/patient_size_input
prod_loss_costs_patient <- aggregate(simulation_patients_history$PROD.LOSS.COST, list(Patient = simulation_patients_history$SIMID), sum)
mean_prod_loss_costs <- sum(prod_loss_costs_patient$x)/patient_size_input
future_medical_costs_patient <- aggregate(simulation_patients_history$FUTURE.COST.MEDICAL, list(Patient = simulation_patients_history$SIMID), sum)
mean_future_medical_costs <- sum(future_medical_costs_patient$x)/patient_size_input
future_nonmedical_costs_patient <- aggregate(simulation_patients_history$FUTURE.COST.NONMEDICAL, list(Patient = simulation_patients_history$SIMID), sum)
mean_future_nonmedical_costs <- sum(future_nonmedical_costs_patient$x)/patient_size_input
# QALYs
total_qalys_patient <- aggregate(simulation_patients_history$QALY, list(Patient = simulation_patients_history$SIMID), sum)
mean_total_qalys <- sum(total_qalys_patient$x)/patient_size_input
### Return model outcomes:
return(list(simulation_patients_history=simulation_patients_history,
mean_life_expectancy = mean_life_expectancy,
mean_CHF_rate = mean_CHF_rate, mean_BLIND_rate = mean_BLIND_rate, mean_ULCER_rate = mean_ULCER_rate, mean_STROKE_rate = mean_STROKE_rate,
mean_AMP1_rate = mean_AMP1_rate, mean_AMP2_rate = mean_AMP2_rate, mean_MI_rate = mean_MI_rate, mean_RENAL_rate = mean_RENAL_rate,
mean_total_costs = mean_total_costs,
mean_total_qalys = mean_total_qalys,
mean_inf_care_costs = mean_inf_care_costs,
mean_prod_loss_costs = mean_prod_loss_costs,
mean_ihd_costs = mean_ihd_costs,
mean_mi_costs = mean_mi_costs,
mean_chf_costs = mean_chf_costs,
mean_stroke_costs = mean_stroke_costs,
mean_amp_costs = mean_amp_costs,
mean_blind_costs = mean_blind_costs,
mean_ulcer_costs = mean_ulcer_costs,
mean_complication_costs = mean_complication_costs,
mean_nocomp_costs = mean_nocomp_costs,
mean_tx_costs = mean_tx_costs,
mean_future_medical_costs = mean_future_medical_costs,
mean_future_nonmedical_costs = mean_future_nonmedical_costs)
) # end return parameters
} #end SMDMII_model_simulation function
# The vector below contains the names of all risk factors used to predict macrovascular complications in the model.
risk_factors_macrovascular <- c("AFRO", "AGE.DIAG", "FEMALE", "INDIAN", "ATFIB", "BMI", "eGFR", "eGFR60less", "HbA1c", "HDL",
"LDL", "LDL35more", "MMALB", "PVD", "SBP", "SMOKER", "WBC", "AMP.HIST", "CHF.HIST", "IHD.HIST",
"STROKE.HIST", "ULCER.HIST")
# Besides the risk factors, there are two other parameters used in the UKPDS equations called "lambda" and "ro". We added them below.
# Now we have the names of all the parameters (lambda, ro and risk factors) used to predict macrovascular risks in the model.
parameters_macrovascular <- c("lambda", "ro", risk_factors_macrovascular)
# And now, below we have the regression coefficients as reported in the UKPDS paper ESM Table 4.
# Note that not all risk factors are used to predict all complications. For that reason, you see some 0's in the regression coefficients below.
# The format for each vector below is c(lambda, ro, risk factors) where the values are taken from the UKPDS paper ESM Table 4.
CHF <- c(-12.332, 1.514, 0, 0.068,  0, 0, 1.562, 0.072, 0, -0.220, 0, 0, 0.012, 0, 0.771, 0.479, 0, 0, 0, 0.658, 0, 0, 0, 0.654)
risk_factors_macrovascular
parameters_macrovascular
CHF
data.frame(CHF)
?data.frame
data.frame(CHF, row.names = parameters_macrovascular)
# The vector below contains the names of all risk factors used to predict macrovascular complications in the model.
risk_factors_macrovascular <- c("AFRO", "AGE.DIAG", "FEMALE", "INDIAN", "ATFIB", "BMI", "eGFR", "eGFR60less", "HbA1c", "HDL",
"LDL", "LDL35more", "MMALB", "PVD", "SBP", "SMOKER", "WBC", "AMP.HIST", "CHF.HIST", "IHD.HIST",
"STROKE.HIST", "ULCER.HIST")
# Besides the risk factors, there are two other parameters used in the UKPDS equations called "lambda" and "ro". We added them below.
# Now we have the names of all the parameters (lambda, ro and risk factors) used to predict macrovascular risks in the model.
parameters_macrovascular <- c("lambda", "ro", risk_factors_macrovascular)
# And now, below we have the regression coefficients as reported in the UKPDS paper ESM Table 4.
# Note that not all risk factors are used to predict all complications. For that reason, you see some 0's in the regression coefficients below.
# The format for each vector below is c(lambda, ro, risk factors) where the values are taken from the UKPDS paper ESM Table 4.
CHF <- c(-12.332, 1.514, 0, 0.068,  0, 0, 1.562, 0.072, 0, -0.220, 0, 0, 0.012, 0, 0.771, 0.479, 0, 0, 0, 0.658, 0, 0, 0, 0.654)
IHD <- c(-6.709, 1.276, 0, 0.016, -0.532, 0, 0, 0, -0.053, 0, 0, -0.065, 0.023, 0, 0, 0.486, 0.058, 0, 0, 0.526, 0.824, 0, 0, 0)
# first MI for males: exponential distribution ro = 1 (2nd element in vector) --> explanation below in "annual_p_weibull" function
FMIMALE <- c(-8.791, 1, -0.83, 0.045, 0 , 0.279, 0, 0, 0, 0, 0.108, -0.049, 0.023, 0, 0.203, 0.340, 0.046, 0.277, 0.026, 0.743, 0.814, 0.846, 0.448, 0)
# first MI for females
FMIFEMALE <- c(-8.708, 1.376, -1.684, 0.041, 0, 0, 0, 0, 0, -0.28, 0.078, 0, 0, 0.035, 0.277, 0.469, 0.056, 0.344, 0.07, 0, 0.853, 0.876, 0, 0)
# second MI: exponential distribution ro = 1 (2nd element in vector)
SMI <- c(-4.179, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.021, 0, 0.344, 0, 0, 0, 0, 0, 0, 0, 0, 0)
# first stroke
FSTROKE <- c(-13.053, 1.466, 0, 0.066, -0.42, 0, 1.476, 0, 0, -0.190, 0.092, 0, 0.016, 0, 0.420, 0, 0.170, 0.331, 0.040, 1.090, 0, 0.481, 0, 0)
# second stroke
SSTROKE <- c(-9.431, 1.956, 0, 0.046, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.537, 0, 0, 0.656, 0, 0, 0, 0, 0, 0)
data.frame(CHF, IHD, FMIMALE, FMIFEMALE, SMI, FSTROKE, SSTROKE, row.names = parameters_macrovascular)
macro_df <- data.frame(CHF, IHD, FMIMALE, FMIFEMALE, SMI, FSTROKE, SSTROKE, row.names = parameters_macrovascular)
getwd()
write.csv(macro_df,"UKPDS_macrovascular_coef.csv")
read.csv("input/UKPDS_macrovascular_coef.csv")
macrovascular_coef <- read.csv("input/UKPDS_macrovascular_coef.csv")
macrovascular_coef
rownames(macrovascular_coef)
macrovascular_coef$X
macrovascular_coef$X-2
c(macrovascular_coef$X)
c(macrovascular_coef$X,-2)
macrovascular_coef$X[-2]
macrovascular_coef$X[1:]
macrovascular_coef$X[1:2]
macrovascular_coef$X[-1:2]
macrovascular_coef$X[-(1:2)]
risk_factors_macrovascular
macrovascular_coef$X[-(1:2)] == risk_factors_macrovascular
macrovascular_coef$X[-(1:2)]
macrovascular_coef$X[-(1:2)]
macrovascular_coef$X
parameters_macrovascular
macrovascular_coef$X == parameters_macrovascular
macrovascular_coef
CHF
macrovascular_coef$CHF
macrovascular_coef$CHF == CHF
macrovascular_risk_equations
macrovascular_coef
risk_factors_macrovascular
macrovascular_coef
# Variable defined to keep track of simulation time (delete afterwards)
init <- Sys.time()
# Model function:
source("R/SMI in type II diabetes - HE model v3.R")
# Control variables of simulation
npats <- 5 # Number of patients in simulation
tx.cost <- 0 # Total treatment cost
treateff.start <- 1 # Cycle in which treatment effect starts
treateff.end <- 4 # Cycle in which treatment effect ends
treateff.decline <- 2 # Cycle in which treatment effect starts to decline linearly
treateff.hba1c <- -1.82 # Treatment effect on HbA1c (in absolute %-points HbA1c)
treateff.hdl <- 0 # Treatment effect on HDL-cholesterol (absolute effect, which unit??)
treateff.ldl <- 0 # Treatment effect on LDL-cholesterol (absolute effect, which unit??)
# The sim.vars object collects all parameters that define the simulation into one object
# Then, it is saved with the output of the simulation. This way, if we  have multiple output files, we always have the information
# on the relevant input parameters that were used to produce the output.
sim.vars <- list(npats, tx.cost, mget(apropos('treateff.')))
# A patient-level model make use of patient characteristics.
# QUESTION: still some issues, ask for units.
baseline_characteristics <- read.csv("/input/UK/baseline_characteristics_UK.csv", sep=",")
# baseline_characteristics <- read.csv("/input/UK/baseline_characteristics_UK_rank_1_study_pop.csv", sep=",")
# Direct costs of diabetes-related complications for UK are age-gender dependent.
male_cost_inputs   <- read.csv("/input/UK/Event cost male 2020.csv", sep=",")
female_cost_inputs <- read.csv("/input/UK/Event cost female 2020.csv", sep=",")
# When a societal perspective is adopted, we also have future costs. This are obtained from the PAID online tool.
future_medical_cost_inputs <- read.csv("/input/UK/UKPAID__AllORUnrelated_Costs_2020.csv", sep=",") # Ingelin: 15/12/2020
future_nonmedical_cost_inputs <- read.csv("/input/UK/UK_nonmedical_futurecosts_data.csv", sep=",") # UK costs updated 11/12/2020 - corrected version from Hamraz
# Utilities are UK-based and age/gender dependent
qol_inputs <- read.csv("/input/UK/qol_inputs_UK.csv", sep=",")
# TODO: also extract output processing scripts to here.
### Run the model below for females and males separately.
##### Females #####
# Intervention
sim_results_female <- SMDMII_model_simulation(npats,  #patient_size_input:
1,  #female_input, 1 = female
tx.cost, #tx_cost_input --> Gimon
c(treateff.hba1c,treateff.start,treateff.end,treateff.decline), #treatment_effect_HbA1c_input --> from COMPAR + Assumption
c(treateff.hdl,treateff.start,treateff.end,treateff.decline),  #treatment_effect_HDL_input
c(treateff.ldl, treateff.start,treateff.end,treateff.decline),  #treatment_effect_LDL_input --> from COMPAR + Assumption
0, #treatment_effect_BMI_input from MH2020
0.035, #cost_disc_rate_input
0.035, #qol_disc_rate_input
65, #retirement_age_input
0, #run_PSA_input, 0 == no PSA
77 #seed_input
)
# Results tables
sim_CE_results_female_table <- matrix(c(sim_results_female$mean_complication_costs,sim_results_female$mean_nocomp_costs, sim_results_female$mean_tx_costs,
sim_results_female$mean_inf_care_costs, sim_results_female$mean_prod_loss_costs,
sim_results_female$mean_future_medical_costs, sim_results_female$mean_future_nonmedical_costs,
sim_results_female$mean_total_costs, sim_results_female$mean_total_qalys), nrow = 1)
colnames(sim_CE_results_female_table) <- c("Complication costs", "No complication costs", "Tx costs","Informal care costs", "Productivity costs",
"Future medical costs", "Future non-medical costs", "Total costs", "Total QALYs")
rownames(sim_CE_results_female_table) <- "Intervention"
#View(sim_CE_results_female_table)
getwd()
# Variable defined to keep track of simulation time (delete afterwards)
init <- Sys.time()
# Model function:
source("R/SMI in type II diabetes - HE model v3.R")
# Control variables of simulation
npats <- 5 # Number of patients in simulation
tx.cost <- 0 # Total treatment cost
treateff.start <- 1 # Cycle in which treatment effect starts
treateff.end <- 4 # Cycle in which treatment effect ends
treateff.decline <- 2 # Cycle in which treatment effect starts to decline linearly
treateff.hba1c <- -1.82 # Treatment effect on HbA1c (in absolute %-points HbA1c)
treateff.hdl <- 0 # Treatment effect on HDL-cholesterol (absolute effect, which unit??)
treateff.ldl <- 0 # Treatment effect on LDL-cholesterol (absolute effect, which unit??)
# The sim.vars object collects all parameters that define the simulation into one object
# Then, it is saved with the output of the simulation. This way, if we  have multiple output files, we always have the information
# on the relevant input parameters that were used to produce the output.
sim.vars <- list(npats, tx.cost, mget(apropos('treateff.')))
# A patient-level model make use of patient characteristics.
# QUESTION: still some issues, ask for units.
baseline_characteristics <- read.csv("/input/UK/baseline_characteristics_UK.csv", sep=",")
# baseline_characteristics <- read.csv("/input/UK/baseline_characteristics_UK_rank_1_study_pop.csv", sep=",")
getwd()
# A patient-level model make use of patient characteristics.
# QUESTION: still some issues, ask for units.
baseline_characteristics <- read.csv("/input/UK/baseline_characteristics_UK.csv", sep=",")
# baseline_characteristics <- read.csv("/input/UK/baseline_characteristics_UK_rank_1_study_pop.csv", sep=",")
